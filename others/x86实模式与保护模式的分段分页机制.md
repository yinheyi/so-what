## 实模式与保护模式下的分段分页机制

### 实模式
在实模式下，CPU不会为任务提供任务的保护机制，代码任意运行。8086处理器是学习实模式的常用例子。它内部大致有以下寄存器：
- 8个16位的通用寄存器：
    - AX (可以拆分成两个AH/AL的8位寄存器)
    - BX (BH,BL)
    - CX (CH,CL)
    - DX (DH,DL)
    - SI (source index,      源索引寄存器)
    - DI (destination index, 目的索引寄存器)
    - BP (base pointer,      基数指针寄存器)
    - SP (stack pointer,     堆栈指针寄存器)
- 段寄存器
    - CS (code segment,      代码段寄存器)
    - DS (data segment,      数据段寄存器)
    - ES (extra segment,     附加段寄存器)
    - SS (stack segment,     堆栈段寄存器)
- 专用寄存器
    - IP (instruction pointer, 指令指针寄存器， 它只与CS一起使用,只有处理器才能直接改变它的值)
    - FLAGS (标志位寄存器)

### 实模式下的分段机制.
在实模式下，当处理器访问内存时，它把指令中的指针的内存地址看成是段内的偏移地址，而不是物理地址: CS与IP一起使用,内存地址与DS(默认使用DS，也可以指定ES寄存器)一起使用. 具体来说，段地址左移4位 ＋ 偏移地址  就得到了分段模式下的线段地址(不启动分页时，就这是物理地址).

### 32位下的保护模式
保护模式是指CPU从硬件机制上提供了用户程序对内存的访问限制，为多用户多任务的程序进行了彼此隔离，防止因某个程序的编写错误影响到操作系统和其它用户。保护模式下提供了修改段寄存器的保护/代码段的保护/栈操作时的保护/数据访问的保护等。具体如何保护的，得详细看看《x86汇编语言从实模式到保护模式》一书，里面说的还是很明白的。如果不写操作系统的话，真的没有太大必要了解很清楚，因为看完之后过一段时间对会忘记了.

### 保护模式下的分段机制
在32位处理器中，在原有的CS/DS/ES/SS段寄存器的基础上对增加了FS/GS段寄存器，并且每一个16位的段寄存器都对应了一个描述符高速缓存器。 在32的保存模式下,段寄存器中存放不是段地址，而是段的描述符的索引号。过程是这样的：在使用一个段之前都需要把该段的描述符(占6个字节)登记注册的段描述符表中(GDT或LDT),在使用一个段时，在段寄存器是放在是该段的描述符在段描述符表中的索引号，cpu会自动把段对应的描述符加载到段寄存器对应的调整缓存器中(这里面有段地址).
- 全局描述符表(GDT): 存放全局的段描述符.
- GDTR: 48位的全局描述符表寄存器，前32位存放了GDT在内存起始位置的线性地址, 后16位存放了全局描述符表的大小(16位,64Kb, 每一个段描述符大小8b, 所以最多可以定义8192个段描述符).
- 局部描述符表(LDT): 存放每一个任务自己段描述符.
- LDTR: LDT寄存器，类似GDTR, 保存当前任务的LDT的位置信息.
- 任务状态段(TSS): 为了保存任务的状态，并在下一次重新执行时恢复它们，每个任务都应用一个额外的内存区域保存上下文相关的信息(各寄存器的值)，这就叫做任务状态段. 它有固定的格式，最小为104字节.
- TR寄存器：指向当前任务的TSS.

段部件负责求出线性地址.

### 32位下的分页机制
- 页目录
- 页表
